#!/bin/bash

# Check if the script is run as root
if [ "$EUID" -ne 0 ]; then
  echo "Please run this script with sudo privileges."
  exit 1
fi

#Installing missing packages
packages=(ufw libnotify-bin dbus gnome-session gnome-shell dbus-x11 notification-daemon dunst zenity)

# missing_packages=false

# for package in "${packages[@]}"; do
#     if ! dpkg -s "$package" &> /dev/null; then
#         echo "Package $package is not installed."
#         missing_packages=true
#     fi
# done

# if [ "$missing_packages" = true ]; then
#     echo "Installing missing packages..."
#     apt-get update
#     apt-get install -y "${packages[@]}"
# else
#     echo "All packages are already installed."
# fi

apt-get update
apt-get install -y "${packages[@]}"

# Prompt for the path to the .ovpn file
read -p "Please enter the full path to your .ovpn file: " OVPN_FILE

if [ ! -f "$OVPN_FILE" ]; then
    echo "Error: File $OVPN_FILE not found."
    exit 1
fi

# --- Extracting data from the .ovpn file ---
VPN_SERVER_IP=$(grep -E "^remote\s" "$OVPN_FILE" | awk '{print $2}')
VPN_PORT=$(grep -E "^remote\s" "$OVPN_FILE" | awk '{print $3}')
PROTO=$(grep -E "^proto\s" "$OVPN_FILE" | awk '{print $2}')

if [ -z "$VPN_SERVER_IP" ] || [ -z "$VPN_PORT" ] || [ -z "$PROTO" ]; then
    echo "Error: Could not extract VPN server IP address, port, or protocol from the file."
    exit 1
fi

echo "Found VPN data: Server $VPN_SERVER_IP, Port $VPN_PORT, Protocol $PROTO"

ufw status | grep -q "Status: active"
if [ $? -ne 0 ]; then
    echo "UFW is not active. Activating UFW..."
    ufw enable
fi

USER_TO_ALLOW=$(sudo -E env | grep '^SUDO_USER=' | cut -d'=' -f2)
if [ -n "$USER_TO_ALLOW" ]; then
    USER_TO_ALLOW=$(who | awk '{print $1}' | head -n 1)
    echo "Sudo user detected: $USER_TO_ALLOW"
    
    if ! grep -q "^@includedir /etc/sudoers.d" /etc/sudoers; then
        echo "Adding @includedir to /etc/sudoers..."
        echo "@includedir /etc/sudoers.d" >> /etc/sudoers
        echo "@includedir directive added to /etc/sudoers"
    fi
    
    SUDOERS_FILE="/etc/sudoers.d/killswitch"
    
    needs_update=0
    
    if [ ! -f "$SUDOERS_FILE" ]; then
        echo "Killswitch sudoers file not found, creating..."
        needs_update=1
    else
        echo "Checking existing killswitch sudoers rules..."
        
        if ! grep -q "$USER_TO_ALLOW ALL=NOPASSWD: /usr/local/bin/killswitch-on.sh" "$SUDOERS_FILE"; then
            needs_update=1
        fi
        if ! grep -q "$USER_TO_ALLOW ALL=NOPASSWD: /usr/local/bin/killswitch-off.sh" "$SUDOERS_FILE"; then
            needs_update=1
        fi
        # if ! grep -q "$USER_TO_ALLOW ALL=NOPASSWD: /etc/openvpn/vpn-disconnected.sh" "$SUDOERS_FILE"; then
        #     needs_update=1
        # fi
        if ! grep -q "$USER_TO_ALLOW ALL=NOPASSWD: /usr/local/bin/vpn-monitor.sh" "$SUDOERS_FILE"; then
            needs_update=1
        fi
        
        if [ $needs_update -eq 0 ]; then
            echo "✅ All killswitch sudoers rules already exist"
        fi
    fi

    if [ $needs_update -eq 1 ]; then
        echo "Updating killswitch sudoers rules..."
        
        cat > "$SUDOERS_FILE" << EOL
# Killswitch sudoers rules
# Generated by killswitch installation script
$USER_TO_ALLOW ALL=NOPASSWD: /usr/local/bin/killswitch-on.sh
$USER_TO_ALLOW ALL=NOPASSWD: /usr/local/bin/killswitch-off.sh
# $USER_TO_ALLOW ALL=NOPASSWD: /etc/openvpn/vpn-disconnected.sh
$USER_TO_ALLOW ALL=NOPASSWD: /usr/local/bin/vpn-monitor.sh
EOL
        
        chmod 440 "$SUDOERS_FILE"
        chown root:root "$SUDOERS_FILE"
        
        if visudo -c -f "$SUDOERS_FILE" > /dev/null 2>&1; then
            echo "✅ Killswitch sudoers rules updated in $SUDOERS_FILE"
        else
            echo "❌ Error: Invalid sudoers syntax in $SUDOERS_FILE"
            rm -f "$SUDOERS_FILE"
            exit 1
        fi
    fi
    
else
    echo "Could not determine the sudo user. Sudoers rules will not be changed."
fi


# --- Creating the Kill Switch On script ---
cat > /usr/local/bin/killswitch-on.sh << EOL
#!/bin/bash
if [ "\$EUID" -ne 0 ]; then echo "Please run with sudo."; exit 1; fi

echo "Activating VPN Kill Switch..."

# Allow traffic to the VPN server
ufw allow out to $VPN_SERVER_IP port $VPN_PORT proto $PROTO
ufw allow in to $VPN_SERVER_IP port $VPN_PORT proto $PROTO
ufw allow out on tun0 #from any to any
ufw allow in on tun0 #from any to any
ufw allow out on wg0 #from any to any
ufw allow in on wg0 #from any to any

# Block all other outgoing and incoming traffic
ufw default deny outgoing
ufw default deny incoming

# Enable UFW
ufw enable
#notify-send -u critical -i network-vpn "Kill Switch Activated" "All traffic, except for the VPN, is blocked."

zenity --warning \
       --title="Kill Switch Activated" \
       --text="All traffic, except for the VPN, is blocked." \
       --width=300
echo "Kill Switch activated."
EOL

# --- Creating the Kill Switch Off script ---
cat > /usr/local/bin/killswitch-off.sh << EOL
#!/bin/bash
if [ "\$EUID" -ne 0 ]; then echo "Please run with sudo."; exit 1; fi

echo "Deactivating VPN Kill Switch..."
ufw default allow outgoing
ufw default allow incoming
#notify-send -u critical -i network-vpn-offline "Kill Switch Deactivated"
zenity --warning \
       --title="Kill Switch Deactivated" \
       --text="All traffic is allowed." \
       --width=300
echo "Kill Switch deactivated."
EOL

# --- Creating the VPN Disconnect Notification Script ---
# cat > /etc/openvpn/vpn-disconnected.sh << EOL
# #!/bin/bash
# # This script is run by OpenVPN, environment variables may not be available.

# # Find the active user to send a notification to their desktop
# ACTIVE_USER=\$(loginctl list-sessions | awk 'NR==2 {print \$3}')

# # Check if a user was found
# if [ -n "\$ACTIVE_USER" ]; then

#     # Check if the Kill Switch is active (UFW should be active and blocking outgoing traffic)
#     # Search for the "Default:" line in the UFW status and check if it contains "deny (outgoing)"
#     if ufw status | grep 'Default:' | grep -q 'deny (outgoing)'; then
#         # If Kill Switch is active
#         MESSAGE="VPN connection lost. Kill Switch is ACTIVE. All traffic is blocked."
#         ICON="network-error"
#     else
#         # If Kill Switch is NOT active
#         MESSAGE="VPN connection lost. WARNING: Kill Switch is NOT active!"
#         ICON="network-warning"
#     fi

#     # Use su to send the notification as the active user
#     # The -u critical flag makes the notification more prominent
#     DISPLAY=:0 su \$ACTIVE_USER -c "notify-send -u critical -i '\$ICON' '\$MESSAGE'"
# fi
# EOL

# --- Creating the Interactive VPN Monitor Script ---
cat > /usr/local/bin/vpn-monitor.sh << 'EOL'
#!/bin/bash
CHECK_HOST="172.17.32.1"
TUN_INTERFACE="tun0"
CHECK_INTERVAL=5
PAUSE_MINUTES=5
SNOOZE_MINUTES=1
SNOOZE_LIMIT=3

LAST_STATE="UP"

echo "VPN monitoring service started. Interface: $TUN_INTERFACE, Host: $CHECK_HOST"

while true; do
    if ping -c 1 -W 3 -I "$TUN_INTERFACE" "$CHECK_HOST" > /dev/null 2>&1; then
        if [ "$LAST_STATE" = "DOWN" ]; then
            echo "$(date): Connection restored."
            ACTIVE_USER=$(loginctl list-sessions --no-legend | awk '/seat0/ {print $3; exit}')
            if [ -n "$ACTIVE_USER" ]; then
                USER_ID=$(id -u "$ACTIVE_USER")
                DBUS_ADDRESS="unix:path=/run/user/$USER_ID/bus"
                STATE_FILE="/run/user/$USER_ID/vpn_monitor.state"
                SNOOZE_COUNT_FILE="/run/user/$USER_ID/vpn_monitor.snooze_count"

                sudo -u "$ACTIVE_USER" \
                     DBUS_SESSION_BUS_ADDRESS="$DBUS_ADDRESS" \
                     DISPLAY=:0 \
                     notify-send -i network-transmit-receive 'VPN Monitor' 'Connection restored'
                echo 0 > "$STATE_FILE"
                echo 0 > "$SNOOZE_COUNT_FILE"
            fi
        fi
        LAST_STATE="UP"
    else
        ACTIVE_USER=$(loginctl list-sessions --no-legend | awk '/seat0/ {print $3; exit}')
        if [ -z "$ACTIVE_USER" ]; then
            sleep "$CHECK_INTERVAL"
            continue
        fi

        USER_ID=$(id -u "$ACTIVE_USER")
        DBUS_ADDRESS="unix:path=/run/user/$USER_ID/bus"
        STATE_FILE="/run/user/$USER_ID/vpn_monitor.state"
        SNOOZE_COUNT_FILE="/run/user/$USER_ID/vpn_monitor.snooze_count"

        mkdir -p "$(dirname "$STATE_FILE")"
        [ -f "$STATE_FILE" ] || echo 0 > "$STATE_FILE"
        [ -f "$SNOOZE_COUNT_FILE" ] || echo 0 > "$SNOOZE_COUNT_FILE"

        SNOOZE_UNTIL=$(cat "$STATE_FILE")
        CURRENT_TIME=$(date +%s)
        SNOOZE_COUNT=$(cat "$SNOOZE_COUNT_FILE")

        if [ "$SNOOZE_COUNT" -ge "$SNOOZE_LIMIT" ]; then
            LAST_STATE="DOWN"
            sleep "$CHECK_INTERVAL"
            continue
        fi

        if [ "$CURRENT_TIME" -gt "$SNOOZE_UNTIL" ]; then
            echo "$(date): Connection lost or still down. Sending notification."

            ACTION=$(sudo -u "$ACTIVE_USER" \
                         DBUS_SESSION_BUS_ADDRESS="$DBUS_ADDRESS" \
                         DISPLAY=:0 \
                         notify-send -u critical -t 15000 \
                         --action="pause=Pause for $PAUSE_MINUTES min" \
                         --action="snooze=Snooze for $SNOOZE_MINUTES min" \
                         "VPN Connection Lost!" \
                         "<b>$(date)</b>
                          No response from $CHECK_HOST via $TUN_INTERFACE.
                          <b>Your traffic may not be secure. Avoid sensitive activity.</b>" 2>/dev/null)

            case "$ACTION" in
                "pause")
                    NEW_SNOOZE_TIME=$((CURRENT_TIME + PAUSE_MINUTES * 60))
                    echo "$NEW_SNOOZE_TIME" > "$STATE_FILE"
                    echo "Notifications paused for $PAUSE_MINUTES minutes."
                    ;;
                "snooze")
                    NEW_SNOOZE_TIME=$((CURRENT_TIME + SNOOZE_MINUTES * 60))
                    echo "$NEW_SNOOZE_TIME" > "$STATE_FILE"
                    NEW_SNOOZE_COUNT=$((SNOOZE_COUNT + 1))
                    echo "$NEW_SNOOZE_COUNT" > "$SNOOZE_COUNT_FILE"
                    echo "Notification snoozed for $SNOOZE_MINUTES minute. Snooze count: $NEW_SNOOZE_COUNT"
                    ;;
                *)
                    NEW_SNOOZE_TIME=$((CURRENT_TIME + SNOOZE_MINUTES * 60))
                    echo "$NEW_SNOOZE_TIME" > "$STATE_FILE"
                    NEW_SNOOZE_COUNT=$((SNOOZE_COUNT + 1))
                    echo "$NEW_SNOOZE_COUNT" > "$SNOOZE_COUNT_FILE"
                    echo "Notification closed. Snooze count: $NEW_SNOOZE_COUNT"
                    ;;
            esac
        fi
        LAST_STATE="DOWN"
    fi
    
    sleep "$CHECK_INTERVAL"
done
EOL

# --- Creating the Notification Script ---
cat > /usr/local/bin/killswitch-notify.sh << EOL
#!/bin/bash
# This script sends a notification about the Kill Switch status.
ACTIVE_USER=$(loginctl list-sessions | awk 'NR==2 {print $3}')
    
if [ -n "\$ACTIVE_USER" ]; then
    # Check Kill Switch status
    if sudo ufw status verbose | grep -q "Default:.*deny (incoming).*deny (outgoing)"; then
        MESSAGE="Kill Switch is ACTIVE. All traffic is blocked."
        ICON="network-warning"
    else
        MESSAGE="WARNING: Kill Switch is NOT active!"
        ICON="network-warning"
    fi
    DISPLAY=:0 su \$ACTIVE_USER -c "notify-send -u critical -i '\$ICON' '\$MESSAGE'"
    # Log the notification
    LOG_FILE="/var/log/killswitch-notify.log"
    echo "$(date): Notification sent to user \$ACTIVE_USER" >> \$LOG_FILE
fi
EOL


# --- Making the scripts executable ---
chmod +x /usr/local/bin/killswitch-on.sh
chmod +x /usr/local/bin/killswitch-off.sh
# chmod +x /etc/openvpn/vpn-disconnected.sh
chmod +x /usr/local/bin/killswitch-notify.sh
chmod +x /usr/local/bin/vpn-monitor.sh

# --- Setting up Systemd Services ---
cat > /etc/systemd/system/killswitch.service << EOL
[Unit]
Description=Enable VPN Kill Switch on Boot
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/killswitch-on.sh
User=root
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOL

cat > /etc/systemd/system/killswitch-notify.service << EOL
[Unit]
Description=Send notification about VPN Kill Switch status
After=graphical.target
Requires=graphical.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/killswitch-notify.sh
RemainAfterExit=no

[Install]
WantedBy=default.target
EOL

cat > /etc/systemd/system/vpn-monitor.service << EOL
[Unit]
Description=VPN Connection Monitor with Interactive Notifications
After=network-online.target

[Service]
ExecStart=/usr/local/bin/vpn-monitor.sh
Restart=always
RestartSec=10

[Install]
WantedBy=default.target
EOL

# Reload and enable the services
systemctl daemon-reload
systemctl enable killswitch.service
systemctl enable killswitch-notify.service
systemctl enable vpn-monitor.service

# --- Modifying the .ovpn file ---
# Check if the line has already been added
# if ! grep -q "down /etc/openvpn/vpn-disconnected.sh" "$OVPN_FILE"; then
#     echo -e "\n# Run script on connection drop\ndown /etc/openvpn/vpn-disconnected.sh" >> "$OVPN_FILE"
#     echo "The 'down' directive has been added to your .ovpn file to track connection drops."
# fi

USER_TO_ALLOW=$(who | awk '{print $1}' | head -n 1)
USER_ID=$(id -u "$USER_TO_ALLOW")
echo "$USER_TO_ALLOW"

run_gsettings() {
    sudo -u "$USER_TO_ALLOW" \
        DISPLAY=:0 \
        XDG_RUNTIME_DIR="/run/user/$USER_ID" \
        DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$USER_ID/bus" \
        "$@"
}

echo "=== Setting up shortcuts ==="

current=$(run_gsettings gsettings get org.gnome.settings-daemon.plugins.media-keys custom-keybindings)
echo "Current shortcuts: $current"

skip_on=0
skip_off=0

if [ "$current" != "@as []" ] && [ "$current" != "[]" ]; then
    echo "Checking existing shortcuts for duplicates..."
    
    for path in $(echo "$current" | grep -o "'/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom[0-9]*/'"); do
        clean_path=$(echo "$path" | sed "s/'//g")
        
        name=$(run_gsettings gsettings get "org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:$clean_path" name 2>/dev/null)
        
        if [ "$name" = "'Killswitch On'" ]; then
            echo "Found existing 'Killswitch On' shortcut at $clean_path"
            skip_on=1
        elif [ "$name" = "'Killswitch Off'" ]; then
            echo "Found existing 'Killswitch Off' shortcut at $clean_path"
            skip_off=1
        fi
    done
fi

if [ "$current" = "@as []" ] || [ "$current" = "[]" ]; then
    index=0
else
    highest=$(echo "$current" | grep -o 'custom[0-9]\+' | grep -o '[0-9]\+' | sort -n | tail -1)
    if [ -z "$highest" ]; then
        index=0
    else
        index=$((highest + 1))
    fi
fi

new_paths=""
shortcut1_index=""
shortcut2_index=""

if [ "$skip_on" -eq 0 ]; then
    shortcut1_index=$index
    new_paths="'/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom${index}/'"
    index=$((index + 1))
fi

if [ "$skip_off" -eq 0 ]; then
    shortcut2_index=$index
    if [ -n "$new_paths" ]; then
        new_paths="$new_paths, '/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom${index}/'"
    else
        new_paths="'/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom${index}/'"
    fi
fi

if [ "$current" = "@as []" ] || [ "$current" = "[]" ]; then
    new_list="[$new_paths]"
else
    existing=$(echo "$current" | sed 's/@as //' | sed 's/^\[//' | sed 's/\]$//')
    if [ -n "$existing" ]; then
        new_list="[$existing, $new_paths]"
    else
        new_list="[$new_paths]"
    fi
fi

echo "New shortcuts list: $new_list"
if [ -n "$new_paths" ]; then
    echo "Setting shortcuts list..."
    run_gsettings gsettings set org.gnome.settings-daemon.plugins.media-keys custom-keybindings "$new_list"
    
    if [ $? -eq 0 ]; then
        echo "List updated successfully"
        sleep 1
        if [ "$skip_on" -eq 0 ] && [ -n "$shortcut1_index" ]; then
            echo "Creating Killswitch On shortcut at index $shortcut1_index..."
            run_gsettings gsettings set "org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom${shortcut1_index}/" name "Killswitch On"
            run_gsettings gsettings set "org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom${shortcut1_index}/" command "sudo /usr/local/bin/killswitch-on.sh"
            run_gsettings gsettings set "org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom${shortcut1_index}/" binding "<Control><Super>n"
            echo "✅ Killswitch On created: Ctrl+Super+N"
        fi
        if [ "$skip_off" -eq 0 ] && [ -n "$shortcut2_index" ]; then
            echo "Creating Killswitch Off shortcut at index $shortcut2_index..."
            run_gsettings gsettings set "org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom${shortcut2_index}/" name "Killswitch Off"
            run_gsettings gsettings set "org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom${shortcut2_index}/" command "sudo /usr/local/bin/killswitch-off.sh"
            run_gsettings gsettings set "org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom${shortcut2_index}/" binding "<Control><Super>f"
            echo "✅ Killswitch Off created: Ctrl+Super+F"
        fi
        sleep 1
        echo "Final verification:"
        final_shortcuts=$(run_gsettings gsettings get org.gnome.settings-daemon.plugins.media-keys custom-keybindings)
        echo "Final shortcuts: $final_shortcuts"
        
    else
        echo "❌ Error: Failed to set shortcuts list"
    fi
else
    echo "No new shortcuts to create."
fi

echo "Shortcuts processed."

# --- Printing instructions ---
INSTRUCTIONS="\n\n🎉 Installation complete! 🎉\n
Five scripts have been created:
1. /usr/local/bin/killswitch-on.sh - to activate the protection.
2. /usr/local/bin/killswitch-off.sh - to deactivate the protection.
3. /usr/local/bin/killswitch-notify.sh - to send a notification about the Kill Switch status.
4. /usr/local/bin/vpn-monitor.sh - to send a notification on connection drop (called automatically).
5. Systemd services have been created to run the Kill Switch on boot and send notifications (killswitch.service, killswitch-notify.service).

Two services have been created:
1. /etc/systemd/system/killswitch.service - to enable the Kill Switch on boot.
2. /etc/systemd/system/killswitch-notify.service - to send notifications about the Kill Switch status after boot.
3. /etc/systemd/system/vpn-monitor.service - to monitor VPN connection  with interactive notifications.

Three rules have been added to the sudoers file to allow the user to run the scripts without a password:
$USER_TO_ALLOW ALL=NOPASSWD: /usr/local/bin/killswitch-on.sh
$USER_TO_ALLOW ALL=NOPASSWD: /usr/local/bin/killswitch-off.sh
$USER_TO_ALLOW ALL=NOPASSWD: /usr/local/bin/vpn-monitor.sh

Added shortcuts for the scripts:
1. Killswitch On: Ctrl+Super+N
2. Killswitch Off: Ctrl+Super+F

--- How to use ---
1. Reconnect to your VPN using the aforementioned '$OVPN_FILE' file, which has been modified by this script.

2. Activate the Kill Switch:
   sudo /usr/local/bin/killswitch-on.sh
   Or use a keyboard shortcut: ctrl+Super+N

3. To deactivate the protection, run:
   sudo /usr/local/bin/killswitch-off.sh
   Or use a keyboard shortcut: ctrl+Super+F

IMPORTANT: If you don't have a internet connection after restarting your computer, deactivate the Kill Switch first."

echo -e "$INSTRUCTIONS"
